## Схема Robofeed

Схема, описывающая поля Robofeed, для удобства, построена на основе **getMap()** **ORM**. Но с существенным отличием.

1. Схема имеет вложенности.

1. Родителями скалярных полей выступает не **\Bitrix\Main\ORM\Fields\ScalarField**, а **\Local\Core\Inner\Robofeed\SchemaFields\ScalarField**. У них появились новые общие параметры и методы

1. Модифицированы валидаторы, а так же их коды ошибок

А теперь поподробнее.

---

#### \Bitrix\Main\ORM\Fields\ScalarField

Описывая поля схемы стоит использовать Fields, унаследованные от **\Bitrix\Main\ORM\Fields\ScalarField**.

У **ScalarField** появились следующие новые методы:
+ **public getValidValue()** - после успешной валидации обрабатывает значение (лучший пример - BooleanField) и возвращает его. Преполагается сохранять значения, которые в обязательном порядке прогонялись через него.

+ **public getXmlPath()** - возвращает путь по структуре до филда. Задается при создании поля через **$arParams['xml_path']** (там же, где 'title'), используется в выводе ошибок и описания поля в разделе для разработчиков.

+ **public getXmlExpectedType()** - возвращает описание ожидаемого значения. Задается при создании поля через **$arParams['xml_expected_type']** (там же, где 'title'), используется при выводе вариантов значения поля / ожидаемый тип поля в разделе для разработчиков, а так же при ошибке валидации поля. У некоторых полей имеет значение по умолчанию (таких, как FloatField), у некоторых может быть заполнено вручную (таких, как Enum).

Предполагается, что все значения, переданые на валидаю, проходят через конвертирование в строку ( (string)$value ), поэтому все Fields на вход своих валидаторов ожидают только **string**. Если значение нет - давать пустую строку, **не NULL!**

При этом, вызывая **getValidValue()** после успешной валидации, но передав в него пустую строку, вернет **null**!

Так же под каждое новое Field необходимо писать свою проверку на isRequired().

Подробнее о Fields:

**ScalarField** - базовый Field для всех других Field,

Новые параметры:
+ **xml_path** - Путь до поля в структуре robofeed xml. Используется в выводе ошибок и описания поля в разделе для разработчиков
+ **xml_expected_type** - Описание ожидаемого пзначения. У всех Field задан по дефолту, но можно изменить. Используется при выводе вариантов значения поля / ожидаемый тип поля в разделе для разработчиков, а так же при ошибке валидации поля

**BooleanField** - проверяет поля, которые помечены как "поля, ожидающие значение false или true". К примеру поле в фиде v1 robofeed->offers->offer->@available. Как следствие на вход ожидает (string)true или (string)false. **getValidValue()** вернет N или Y.

**DateField** - поле для даты в формате Y-m-d. На вход ожидает строку, не Type\Date! **getValidValue()** вернет то, что получил.

**DatetimeField** - поле для даты в формате Y-m-d H:i:s. На вход ожидает строку, не Type\Datetime! **getValidValue()** вернет то, что получил.

**EnumField** - поле для списка. Работает как родное. **getValidValue()** вернет то, что получил.

**FloatField** - поле для чисел с плавающей точкой. Проверяет по регулярке, т.к. иные способы не практичны. **getValidValue()** вернет дробь. Если был задан параметр **scale** - округлит.

Новые параметры:
+ **size** - проверяте длину строки дроби. Сделано ввиду необходимости робофид XML. По умолчанию равно 11.

**IntegerField** - поле для проверки целых чисел. **getValidValue()** вернет целое число.

Новые параметры:
+ **size** - проверяте длину строки целого числа. Сделано ввиду необходимости робофид XML. По умолчанию равно 11.

**NumericField** - поле для числа. Проверяет и дроби, и целы числа. **getValidValue()** вернет целое число, если было передано целое число, и дробь, если была передана дробь. Дроби формата "1.0" приведет к 1. Если был передан **scale** - округлит дробь.

Новые параметры:
+ **size** - проверяте длину строки. Сделано ввиду необходимости робофид XML. По умолчанию равно 11.
+ **scale** - округляет, если была передана дробь.

**StringField** - поле для строки. **getValidValue()** вернет строку, обрезанную по **size**, и декодированную через htmlspecialchars_decode().

Новые параметры:
+ **size** - проверяте длину строки. По умолчанию равно 255.

**TextField** - поле для текста, потомок **StringField**. Сделано для description. **getValidValue()** вернет строку, обрезанную по **size**, и декодированную через htmlspecialchars_decode().

Новые параметры:
+ **size** - проверяте длину строки. По умолчанию равно 3000.
+ **html** - разрешить использовать символы ', ", &, >, <. Ожидает true что бы разрешить. По умолчанию запрещены. Сделан для возможности работы с CDATA.

**ReferenceField** - поле, которые указвает, что значение должно принадлежать справочнику.

Новые параметры:
+ **class** - название класса справочника. К примеру \Local\Core\Model\Reference\CurrencyTable::class 
+ **ref_column_name** - поле из класса, с которым будем сравнивать. По умолчанию **CODE**

---

#### Валидация

За валидацию значений по их Field отвечает **\Local\Core\Inner\Robofeed\Scheme\Validate::validateValue()** .

Пример вызыва валидации:
```php
$obResult = new \Bitrix\Main\Result();

# Начало цикла проверок. Представим что тут foreach
$mixVal = 'http://example.com';

$obField = new \Local\Core\Inner\Robofeed\SchemaFields\TextField(
    'test',
    [
        'title'    => 'Site domain',
        'required' => true,
        'xml_path' => 'robofeed->siteDomain',
        'format'   => '/^(https?\:\/\/)/' 
    ]
);

$boolCheckResult = \Local\Core\Inner\Robofeed\Validator\AbstractValidator::validateValue(
    $mixVal,
    $obField,
    $obResult
);

// Применяется для извлечения значения
if( $boolCheckResult )
{
    echo 'success';
    echo $obField->getValidValue($mixVal);
}
# Конец тела проверок

// Применяется в конце цикла проверок, что бы понять
// были ли ошибки при проверку цикла.
if( !$obResult->isSuccess() )
{
    print_r( $obResult->getErrorMessages() );
}
else
{
    echo 'success';
}
```

Для валидации значения необходимо передать в **\Local\Core\Inner\Robofeed\Validator\AbstractValidator::validateValue**
1. Значение
1. Объект Field, унаследованное от **\Local\Core\Inner\Robofeed\SchemaFields\ScalarField**
1. Объект **\Bitrix\Main\Result**

Количество последовательных валидаций не ограничено, и в каждое нужно передать **$obResult**, объявленный в начале. Тем самым в конце валидаций мы сможем выдать информацию по всем ошибкам валидации, либо понять, что схема числа и полностью валидна.

В случае успешной валидации значения на выход стоит прогнать через **public getValidValue()** Field, что бы он привелся к нужному значению.

----
### Контроль версий

Теперь, когда с вводными данными разобрали, переходим к вишенке.

Мы заранее подумали о том, что робофид будем менсяться, но необходимо оставлять возможность поддерживать старые фиды. Для этого у нас реализована система контроля версий.

Такие сущности, как **Robofeed\Importer**, **Robofeed\Schema**, **Robofeed\Validator** и **Robofeed\XMLReader** реализованы по принципу фабрики. Это означает, что к ним надо обращаться через **Factory::factory()**.

Пример:
```php
$obReader = \Local\Core\Inner\Robofeed\XMLReader\Factory::factory(1);
```
В значение фабрики передает версия робофида.

Так же мы учли, хоть и не совсем удобно, определение версии робофида, а так же дату изменения.
```php
$obReader = \Local\Core\Inner\Robofeed\XMLReader\Factory::factory(1);
$obReader->setXmlPath($_SERVER['DOCUMENT_ROOT'].'/example.xml');

// Извлекаем версию
$obResult = $obReader->getRobofeedVersion();
if( $obResult->isSuccess() )
    $obResult->getData(); // ['VERSION' => (integer)]

// Извлекаем дату создания робофида
$obResult = $obReader->getRobofeedLastModified();
if( $obResult->isSuccess() )
    $obResult->getData(); // ['DATE' => 'YYYY-MM-DD HH:MM:SS']
```
Т.к. поля версии и даты общие для всех версий робофида, то не имеет значения из под какой версии обращаться к Ридеру. Но лучше из под версии 1.

----

#### О сущностях
Что есть сущности, за что они отвечают и как связаны.

**Robofeed\XMLReader** - по простому "Ридер". Входная сущность. Отвечает за перебор робофида. Получая перед запуском один из сценариев работы идет по одной из 2х веток - Robofeed\Validator и Robofeed\Import.

**Robofeed\Validator** - валидатор. Запускается при запуске Ридера автоматически. Его цель - собрать данные по соответствии загруженного робофида изначальной XSD схеме. Если в Ридере был задан сценарий XSD валидации, то имеется возможность регулировать, после какого кол-ва ошибочных товаров прекращать валидацию. Регулируется в **.settings_extra.php** по цепочку **robofeed->XMLReader->max_offers_error_count_in_validation**.

**Robofeed\Importer** - импортер. Отвечает за импорт товаров и т.п. в таблицу магазина. Запускается после Валидаторва при сиценарии импорта. По этой причине уже понятно - валиден ли товаров. При этом на момент импорта все не валидные значения отсеяны.

**Robofeed\Schema** - схема, содержащая в себе карту Fields, по которым Валидатор производить проверку значений, а так же из которых вытаскивает конечные значения.

Если описывать весь цикл более подробно, то получается такой сценарий:
1. Создаем новый объект Ридера, передафая в фабрику версию робофида.
1. Задаем путь до робофида.
1. Задаем сценарий - валидация по XSD схеме или импорт.

##### Валидация XSD схемы
1. При констракте Ридер получает Валидатор и Схему, отталкиваясь от своей версии.
1. При запуске Ридер проверяет соответвие заданой версии и версии, объявленной в робофиде. В случае не соответствия прекращет работу, выдавая ошибку FatalException.
1. После проверки версии Ридер запускает проверку согласно версии робофида. При валидации XSD ридер проверит ограниченное кол-во товаров. А если быть точнее, то достигнул заданного лимита ошибок он прекращает проверку, не вызывает FatalException. Просто объявляет, что в виду уже полученых ошибок не видит логики в дальнейшей проверке.
1. Возращается \Bitrix\Main\Result с результатом валидации.

##### Импорт
Повторяет сценаций валидации XSD, но перед запуском Ридера необходимо объявить ID магазина, к которому данный робофид относится.

В отличии от валидации не ведет контрольк допущеных ошибок, а потому не прекращает импорт, пока не достигнут конце робофида и не перебрали всех товаров.

Но стоит отметить, что он импорт товара запускается только после успшного прохождения валидации товара. Говоря иначе товары, содержащие даже не критические ошибки, в импорт не попадут. А те, что попадут, проверенны и имеют приведенные к валидному варианту значения.

----
### Запуск валидации XSD и/или импорта
Важно знать, что Ридер, Валидатор и Импортер могут помимо Exception выкинуть FatalException. По этой причине необходимо все оборачивать в try.

Пример запуска валидации XSD:
```php
try
{

    $obReader = \Local\Core\Inner\Robofeed\XMLReader\Factory::factory(1);
    $obReader->setScript(\Local\Core\Inner\Robofeed\XMLReader\AbstractXMLReader::SCRIPT_XSD_VALIDATE);
    $obReader->setXmlPath( $_SERVER['DOCUMENT_ROOT'].'/example.xml' );

    $obResult = $obReader->run();


    echo '<hr/>';
    dump($obResult->isSuccess());
    if( !$obResult->isSuccess() )
    {
        foreach($obResult->getErrorMessages() as $errorMessage)
        {
            echo $errorMessage.'<hr/>';
        }
    }
}
catch(\Local\Core\Inner\Exception\FatalException $e)
{
    echo 'Критическая остановка';
    dump($e->getMessage());
}
catch(\Exception $e)
{
    echo 'Иная ошибка';
    dump($e->getMessage());
}
```

В случае импорта начало будет выгляить вот так:
```php
$obReader = \Local\Core\Inner\Robofeed\XMLReader\Factory::factory(1);
$obReader->setScript(\Local\Core\Inner\Robofeed\XMLReader\AbstractXMLReader::SCRIPT_IMPORT);
$obReader->setStoreId(1);
$obReader->setXmlPath( $_SERVER['DOCUMENT_ROOT'].'/example.xml' );
```